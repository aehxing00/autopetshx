<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Super Auto Pets Clone</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Fredoka:wght@400;600&display=swap');

        :root {
            --bg-sky: #87CEEB;
            --bg-grass: #90EE90;
            --card-width: 14vh;
            --card-height: 18vh;
            --card-radius: 12px;
            --font-main: 'Fredoka', 'Segoe UI', sans-serif;
            
            /* SAP Colors */
            --c-atk: #e74c3c;
            --c-hp: #f1c40f; 
            --c-gold: #f1c40f;
            --c-freeze: #74b9ff;
            
            --tier-1: #bdc3c7;
            --tier-2: #3498db;
            --tier-3: #9b59b6;
            --tier-4: #e67e22;
            --tier-5: #e74c3c;
            --tier-6: #2ecc71;
        }

        body {
            margin: 0;
            padding: 0;
            width: 100vw;
            height: 100vh;
            overflow: hidden;
            font-family: var(--font-main);
            background: linear-gradient(to bottom, #87CEEB 40%, #8cc63f 40%);
            display: flex;
            flex-direction: column;
            user-select: none;
            -webkit-user-select: none;
        }

        /* Top Bar */
        #top-bar {
            height: 12vh;
            background: rgba(0,0,0,0.2);
            backdrop-filter: blur(5px);
            display: flex;
            justify-content: space-between;
            padding: 0 20px;
            align-items: center;
            color: white;
            text-shadow: 2px 2px 0 #000;
            box-sizing: border-box;
            z-index: 10;
            border-bottom: 2px solid rgba(255,255,255,0.1);
        }
        
        .stat-group {
            display: flex;
            gap: 15px;
        }

        .stat-box {
            display: flex;
            align-items: center;
            gap: 8px;
            background: #333;
            padding: 5px 15px;
            border-radius: 20px;
            border: 2px solid #555;
            font-size: 2.5vh;
            box-shadow: 0 4px 0 rgba(0,0,0,0.3);
            transition: transform 0.1s;
        }
        
        .stat-box:hover {
            transform: translateY(-2px);
        }

        /* Game Area */
        #game-area {
            flex: 1;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            position: relative;
            width: 100%;
        }

        /* Rows */
        .row-container {
            display: flex;
            gap: 1.5vh;
            padding: 1vh;
            align-items: center;
            justify-content: center;
            min-height: 20vh;
            width: 95%;
            perspective: 1000px;
        }
        
        #shop-view {
            width: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 2vh;
        }

        #shop-container, #shop-food-container {
            background: #a1887f;
            padding: 10px;
            border-radius: 15px;
            display: flex;
            gap: 10px;
            border: 3px solid #795548;
            box-shadow: 0 6px 0 #5d4037;
            position: relative;
        }
        
        #shop-container::before {
            content: 'PETS';
            position: absolute;
            top: -20px;
            left: 10px;
            background: #795548;
            color: white;
            padding: 2px 8px;
            border-radius: 5px;
            font-size: 1.5vh;
            font-weight: bold;
        }

        #shop-food-container::before {
            content: 'FOOD';
            position: absolute;
            top: -20px;
            left: 10px;
            background: #795548;
            color: white;
            padding: 2px 8px;
            border-radius: 5px;
            font-size: 1.5vh;
            font-weight: bold;
        }

        /* Cards */
        .pet-card {
            width: var(--card-width);
            height: var(--card-height);
            background: #fff;
            border-radius: var(--card-radius);
            position: relative;
            cursor: pointer;
            box-shadow: 0 4px 0 rgba(0,0,0,0.2);
            transition: transform 0.1s, box-shadow 0.1s;
            display: flex;
            flex-direction: column;
            border: 4px solid #fff;
            box-sizing: border-box;
            overflow: hidden;
        }
        
        .pet-card:hover {
            transform: translateY(-4px);
            box-shadow: 0 8px 0 rgba(0,0,0,0.2);
            z-index: 5;
        }

        .pet-card:active {
            transform: translateY(2px);
            box-shadow: 0 2px 0 rgba(0,0,0,0.2);
        }
        
        .pet-card.selected {
            border-color: #f1c40f;
            box-shadow: 0 0 0 4px #f1c40f, 0 12px 0 rgba(0,0,0,0.2);
            transform: translateY(-8px);
            z-index: 10;
        }
        
        .pet-card.frozen::after, .food-card.frozen::after {
            content: '';
            position: absolute;
            inset: 0;
            background: rgba(135, 206, 250, 0.3);
            border: 3px solid #3498db;
            border-radius: calc(var(--card-radius) - 2px);
            pointer-events: none;
            z-index: 5;
        }

        .pet-bg {
            height: 45%;
            width: 100%;
            border-bottom: 3px solid rgba(0,0,0,0.1);
            position: absolute;
            top: 0;
            left: 0;
            z-index: 0;
        }
        
        .pet-content {
            flex: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
            background: #f5f5f5;
            z-index: 1;
            margin-top: 25%; /* Push emoji down a bit */
        }
        
        .pet-emoji {
            font-size: 7vh;
            z-index: 2;
            filter: drop-shadow(0 4px 2px rgba(0,0,0,0.2));
            transition: transform 0.2s;
        }
        
        .pet-card:hover .pet-emoji {
            transform: scale(1.15) rotate(5deg);
        }
        
        .pet-item-icon {
            position: absolute;
            top: 5px;
            right: 5px;
            font-size: 2.5vh;
            background: #fff;
            border-radius: 50%;
            width: 3.5vh;
            height: 3.5vh;
            display: flex;
            justify-content: center;
            align-items: center;
            box-shadow: 0 2px 2px rgba(0,0,0,0.2);
            z-index: 4;
            border: 1px solid #ddd;
        }
        
        .pet-info-top {
             position: absolute;
             top: 5px;
             left: 5px;
             display: flex;
             flex-direction: column;
             gap: 2px;
             z-index: 4;
        }

        .pet-level-badge {
             font-size: 1.2vh;
             font-weight: 800;
             color: #333;
             background: #fff;
             padding: 2px 5px;
             border-radius: 4px;
             box-shadow: 0 2px 0 rgba(0,0,0,0.1);
             text-align: center;
        }

        .xp-bar {
            display: flex;
            gap: 2px;
            background: rgba(0,0,0,0.2);
            padding: 2px;
            border-radius: 3px;
        }

        .xp-segment {
            width: 6px;
            height: 4px;
            background: #eee;
            border-radius: 1px;
        }

        .xp-segment.filled {
            background: #f1c40f;
            box-shadow: 0 0 2px #f39c12;
        }
        
        .xp-max {
            font-size: 1vh;
            font-weight: bold;
            color: #fff;
            background: #e67e22;
            padding: 1px 3px;
            border-radius: 3px;
            text-align: center;
            box-shadow: 0 1px 0 rgba(0,0,0,0.2);
        }

        .pet-stats-bar {
            height: 3.5vh;
            display: flex;
            justify-content: space-between;
            padding: 0 6px 6px 6px;
            align-items: center;
            background: #f5f5f5;
            border-radius: 0 0 8px 8px;
            z-index: 2;
        }
        
        .stat-box {
            width: 45%;
            height: 2.8vh;
            border-radius: 1.4vh;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 1.6vh;
            font-weight: 900;
            color: white;
            text-shadow: 1px 1px 0 rgba(0,0,0,0.5);
            box-shadow: 0 2px 0 rgba(0,0,0,0.2) inset;
        }
        
        .stat-box.atk { background: var(--c-atk); }
        .stat-box.hp { background: var(--c-hp); }

        /* Food Card */
        .food-card {
            width: var(--card-width);
            height: var(--card-height);
            background: #fff;
            border-radius: var(--card-radius);
            position: relative;
            cursor: pointer;
            box-shadow: 0 4px 0 rgba(0,0,0,0.2);
            border: 4px solid #fff;
            transition: transform 0.1s;
            display: flex;
            flex-direction: column;
            box-sizing: border-box;
            overflow: hidden;
        }
        
        .food-card:hover {
            transform: translateY(-4px);
            box-shadow: 0 8px 0 rgba(0,0,0,0.2);
        }
        
        .food-card.selected {
            border-color: #f1c40f;
            box-shadow: 0 0 0 4px #f1c40f, 0 12px 0 rgba(0,0,0,0.2);
            transform: translateY(-8px);
        }

        .food-bg {
            height: 50%;
            width: 100%;
            background: radial-gradient(circle at center, #ffeaa7 0%, #fab1a0 100%);
            border-bottom: 3px solid rgba(0,0,0,0.1);
            position: absolute;
            top: 0;
            left: 0;
            z-index: 0;
        }

        .food-content {
            flex: 1;
            display: flex;
            justify-content: flex-end;
            align-items: center;
            flex-direction: column;
            background: #fdfdfd;
            z-index: 1;
            padding-bottom: 1vh;
        }
        
        .food-emoji { 
            font-size: 6vh; 
            margin-bottom: 1vh;
            filter: drop-shadow(0 4px 0 rgba(0,0,0,0.2));
            z-index: 2;
            transition: transform 0.2s;
        }
        
        .food-card:hover .food-emoji {
            transform: scale(1.1) rotate(5deg);
        }
        
        .food-cost { 
            background: #f1c40f; 
            color: #333; 
            padding: 0.3vh 1vh; 
            border-radius: 12px; 
            font-size: 1.8vh; 
            font-weight: bold;
            box-shadow: 0 2px 0 rgba(0,0,0,0.1);
            border: 1px solid rgba(0,0,0,0.1);
            z-index: 2;
        }

        /* Controls */
        #controls-area {
            height: 15vh;
            width: 100%;
            background: #8d6e63;
            border-top: 5px solid #6d4c41;
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 20px;
            padding-bottom: 10px;
            z-index: 10;
            box-shadow: 0 -4px 10px rgba(0,0,0,0.3);
        }
        
        .btn {
            height: 9vh;
            min-width: 9vh;
            border: none;
            border-radius: 15px;
            font-family: var(--font-main);
            font-weight: bold;
            font-size: 2.2vh;
            cursor: pointer;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
            text-shadow: 1px 1px 0 rgba(0,0,0,0.3);
            box-shadow: 0 6px 0 rgba(0,0,0,0.3), 0 6px 0 rgba(0,0,0,0.2) inset;
            border: 2px solid rgba(255,255,255,0.2);
            transition: all 0.1s;
            padding: 0 20px;
            position: relative;
            background-image: linear-gradient(to bottom, rgba(255,255,255,0.1), rgba(0,0,0,0.1));
        }
        
        .btn:active { transform: translateY(4px); box-shadow: 0 2px 0 rgba(0,0,0,0.3); }
        
        .btn-roll { background-color: #e67e22; }
        .btn-end { background-color: #e74c3c; min-width: 15vh; }
        .btn-sell { background-color: #f1c40f; color: #333; text-shadow: none; display: none; }
        .btn-freeze { background-color: #74b9ff; }

        /* Modals */
        .modal-overlay {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.6);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 100;
        }
        
        .modal-box {
            background: #fff;
            padding: 30px;
            border-radius: 20px;
            max-width: 80%;
            width: 500px;
            text-align: center;
            box-shadow: 0 10px 0 rgba(0,0,0,0.1);
            position: relative;
        }
        
        .modal-title { font-size: 2rem; font-weight: bold; margin-bottom: 20px; }
        .modal-btn { background: #2ecc71; color: white; padding: 10px 30px; border: none; border-radius: 10px; font-size: 1.2rem; cursor: pointer; margin-top: 20px; }

        /* Animations */
        @keyframes attackRight { 0% { transform: translateX(0); } 50% { transform: translateX(30px) rotate(10deg); } 100% { transform: translateX(0); } }
        @keyframes attackLeft { 0% { transform: translateX(0); } 50% { transform: translateX(-30px) rotate(-10deg); } 100% { transform: translateX(0); } }
        @keyframes hurt { 0% { transform: scale(1); filter: none; } 50% { transform: scale(0.9); filter: brightness(0.5) sepia(1) hue-rotate(-50deg) saturate(5); } 100% { transform: scale(1); filter: none; } }
        
        .anim-attack-right { animation: attackRight 0.3s; }
        .anim-attack-left { animation: attackLeft 0.3s; }
        .anim-hurt { animation: hurt 0.4s; }

        /* Tooltip */
        #tooltip {
            position: absolute;
            background: #333;
            color: #fff;
            padding: 10px;
            border-radius: 8px;
            pointer-events: none;
            display: none;
            z-index: 1000;
            max-width: 200px;
            font-size: 14px;
        }
        
        /* Mobile Landscape Optimization */
        @media (max-width: 900px) and (orientation: landscape) {
            :root {
                --card-width: 13vh;
                --card-height: 16vh;
            }
            #top-bar { height: 15vh; padding: 0 10px; }
            .stat-box { padding: 2px 8px; font-size: 2vh; gap: 4px; }
            
            #controls-area { height: 18vh; gap: 10px; }
            .btn { font-size: 1.8vh; padding: 0 10px; height: 8vh; min-width: 8vh; }
            
            #shop-container { gap: 4px; padding: 5px; }
            #shop-food-container { gap: 4px; margin-left: 5px; padding-left: 5px; padding: 5px; }
            
            .row-container { gap: 1vh; padding: 0.5vh; min-height: 18vh; }
        }
        
        /* Overlay Message */
        #message-overlay {
            position: absolute;
            top: 40%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 3rem;
            color: white;
            font-weight: bold;
            text-shadow: 2px 2px 0 #000, -1px -1px 0 #000, 1px -1px 0 #000, -1px 1px 0 #000, 1px 1px 0 #000;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s;
            z-index: 50;
            text-align: center;
        }
        
        .damage-number {
             position: absolute;
             color: red;
             font-size: 2rem;
             font-weight: bold;
             text-shadow: 1px 1px 0 white;
             z-index: 20;
             animation: floatUp 1s forwards;
        }
        
        @keyframes floatUp { to { transform: translateY(-50px); opacity: 0; } }
        
        .projectile {
            position: absolute;
            font-size: 2rem;
            z-index: 100;
            transition: all 0.5s linear;
        }
        .corner-btn-container {
            display: flex;
            gap: 10px;
        }

        .corner-btn {
            width: 5vh;
            height: 5vh;
            border-radius: 50%;
            background: rgba(255,255,255,0.2);
            border: 2px solid #fff;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 2.5vh;
            cursor: pointer;
            transition: all 0.2s;
            color: white;
        }
        
        .corner-btn:hover { background: white; color: #333; }

    </style>
</head>
<body>

    <div id="top-bar">
        <div class="stat-group">
            <div class="stat-box" title="ç”Ÿå‘½å€¼">â¤ï¸ <span id="lives">5</span></div>
            <div class="stat-box" title="èƒœåœº">ğŸ† <span id="wins">0</span></div>
            <div class="stat-box" title="å›åˆæ•°">â³ <span id="turn">1</span></div>
            <div class="stat-box" title="é‡‘å¸">ğŸ’° <span id="gold">10</span></div>
        </div>
        <div class="corner-btn-container">
             <div class="corner-btn" id="btn-help" title="å¸®åŠ©">â“</div>
             <div class="corner-btn" id="btn-settings" title="è®¾ç½®">âš™ï¸</div>
        </div>
    </div>

    <!-- Start Menu -->
    <div id="start-menu" class="modal-overlay">
        <div class="modal-box">
            <div class="modal-title">ğŸ¶ Super Auto Pets Clone</div>
            <div class="modal-text" style="text-align: center;">
                æ¬¢è¿æ¥åˆ°ç»å…¸è‡ªèµ°æ£‹ï¼<br><br>
                ç»„å»ºä½ çš„å¯çˆ±åŠ¨ç‰©æˆ˜é˜Ÿã€‚<br>
                ä¸å…¶ä»–é˜Ÿä¼è¿›è¡Œæˆ˜æ–—ã€‚<br>
                åœ¨å¤±å»5æ¡ç”Ÿå‘½ä¹‹å‰èµ¢å¾—10åœºèƒœåˆ©ï¼
            </div>
            <button class="modal-btn" id="btn-start-game">å¼€å§‹æ¸¸æˆ</button>
        </div>
    </div>

    <!-- Help Modal -->
    <div id="help-modal" class="modal-overlay" style="display: none;">
        <div class="modal-box">
            <span class="modal-close" onclick="closeModal('help-modal')">âœ–ï¸</span>
            <div class="modal-title">æ¸¸æˆç©æ³•</div>
            <div class="modal-text" style="max-height: 400px; overflow-y: auto;">
                <b>å•†åº—é˜¶æ®µï¼š</b><br>
                - èŠ±è´¹3é‡‘å¸è´­ä¹°å® ç‰©æˆ–é£Ÿç‰©ã€‚<br>
                - èŠ±è´¹1é‡‘å¸åˆ·æ–°å•†åº—ã€‚<br>
                - è´­ä¹°ç›¸åŒå® ç‰©åˆå¹¶å‡çº§ï¼ˆ+1/+1 å¹¶å¢å¼ºæŠ€èƒ½ï¼‰ã€‚<br>
                - å‡ºå”®å® ç‰©å›æ”¶1é‡‘å¸ï¼ˆç­‰çº§è¶Šé«˜å›æ”¶è¶Šå¤šï¼‰ã€‚<br>
                - å†»ç»“å•†åº—ç‰©å“ä»¥ä¿ç•™è‡³ä¸‹ä¸€å›åˆã€‚<br><br>
                <b>æˆ˜æ–—é˜¶æ®µï¼š</b><br>
                - å…¨è‡ªåŠ¨æˆ˜æ–—ï¼<br>
                - æœ€å‰æ–¹çš„å® ç‰©ï¼ˆå³ä¾§ï¼‰å…ˆæ”»å‡»ã€‚<br>
                - æ”»å‡»åŠ›é«˜é€ æˆæ›´å¤šä¼¤å®³ã€‚<br>
                - å­˜æ´»åˆ°æœ€åçš„é˜Ÿä¼è·èƒœã€‚<br><br>
                <b>ç›®æ ‡ï¼š</b><br>
                - èµ¢å¾—10åœºèƒœåˆ©é€šå…³ï¼
            </div>
        </div>
    </div>

    <!-- Settings Modal -->
    <div id="settings-modal" class="modal-overlay" style="display: none;">
        <div class="modal-box">
            <span class="modal-close" onclick="closeModal('settings-modal')">âœ–ï¸</span>
            <div class="modal-title">è®¾ç½®</div>
            <div class="modal-text" style="text-align: center;">
                <label style="display: flex; align-items: center; justify-content: center; gap: 10px;">
                    <input type="checkbox" id="chk-fast-mode"> å¿«é€Ÿæ¨¡å¼ (åŠ é€ŸåŠ¨ç”»)
                </label>
                <br>
                <button class="btn" style="background: #e74c3c; color: white; padding: 10px 20px; border-radius: 5px;" onclick="location.reload()">é‡æ–°å¼€å§‹</button>
            </div>
        </div>
    </div>

    <div id="game-area">
        <div id="message-overlay">æˆ˜æ–—å¼€å§‹!</div>
        
        <!-- Shop Mode -->
        <div id="shop-view">
            <div class="row-container">
                <div id="shop-container" style="display: flex; gap: 15px;"></div>
                <div id="shop-food-container" style="display: flex; gap: 15px;"></div>
            </div>
        </div>

        <!-- Team Rows -->
        <div class="row-container" id="battle-area" style="width: 100%; justify-content: space-between;">
            <div id="team-container" style="display: flex; gap: 10px; justify-content: flex-end; flex-direction: row-reverse; width: 45%;"></div>
            <div id="enemy-container" style="display: flex; gap: 10px; justify-content: flex-start; width: 45%;"></div>
        </div>
    </div>

    <div id="controls-area">
        <button id="btn-roll" class="btn btn-roll">ğŸ² åˆ·æ–° (1)</button>
        <button id="btn-freeze" class="btn" style="background: #74b9ff; color: white;">â„ï¸ å†»ç»“</button>
        <button id="btn-sell" class="btn btn-sell">ğŸ’° å‡ºå”®</button>
        <button id="btn-end" class="btn btn-end">âš”ï¸ ç»“æŸå›åˆ</button>
    </div>

    <div id="tooltip"></div>

    <script>
        // --- Constants & Data ---
        const TIERS = {
            1: { color: '#bdc3c7', pets: ['ant', 'beaver', 'cricket', 'fish', 'mosquito', 'otter', 'horse', 'pig', 'duck'] },
            2: { color: '#3498db', pets: ['crab', 'dodo', 'elephant', 'flamingo', 'hedgehog', 'peacock', 'rat', 'spider', 'swan', 'shrimp'] },
            3: { color: '#9b59b6', pets: ['badger', 'camel', 'giraffe', 'kangaroo', 'ox', 'turtle', 'rabbit', 'sheep', 'snail', 'dog', 'blowfish', 'whale'] },
            4: { color: '#f1c40f', pets: ['bison', 'deer', 'dolphin', 'hippo', 'penguin', 'rooster', 'skunk', 'worm'] },
            5: { color: '#e74c3c', pets: ['cow', 'crocodile', 'microbe', 'monkey', 'rhino', 'scorpion', 'seal', 'shark', 'turkey', 'eagle'] },
            6: { color: '#2ecc71', pets: ['boar', 'cat', 'dragon', 'fly', 'gorilla', 'leopard', 'mammoth', 'snake', 'tiger', 'octopus'] }
        };

        const PET_DATA = {
            'ant': { name: 'èš‚èš', emoji: 'ğŸœ', tier: 1, atk: 2, hp: 1, desc: 'æ˜å¥: ä½¿ä¸€åªéšæœºå‹å†› +2/+1 * ç­‰çº§' },
            'beaver': { name: 'æµ·ç‹¸', emoji: 'ğŸ¦«', tier: 1, atk: 3, hp: 2, desc: 'å‡ºå”®: ä½¿ä¸¤åªéšæœºå‹å†› +1/+0 * ç­‰çº§' }, // SAP standard: +1 hp? Clone: +1 hp. 
            'cricket': { name: 'èŸ‹èŸ€', emoji: 'ğŸ¦—', tier: 1, atk: 1, hp: 2, desc: 'æ˜å¥: å¬å”¤ä¸€åª 1/1 * ç­‰çº§ çš„åƒµå°¸èŸ‹èŸ€' },
            'zombie_cricket': { name: 'åƒµå°¸èŸ‹èŸ€', emoji: 'ğŸ§Ÿ', tier: 1, atk: 1, hp: 1, desc: '', token: true },
            'fish': { name: 'é±¼', emoji: 'ğŸŸ', tier: 1, atk: 2, hp: 2, desc: 'å‡çº§: ä½¿æ‰€æœ‰å‹å†› +1/+1 * ç­‰çº§' },
            'mosquito': { name: 'èšŠå­', emoji: 'ğŸ¦Ÿ', tier: 1, atk: 2, hp: 2, desc: 'æˆ˜æ–—å¼€å§‹: å¯¹ 1/2/3 ä¸ªéšæœºæ•Œäººé€ æˆ 1 ç‚¹ä¼¤å®³' },
            'otter': { name: 'æ°´ç­', emoji: 'ğŸ¦¦', tier: 1, atk: 1, hp: 2, desc: 'è´­ä¹°: ä½¿ä¸€åªéšæœºå‹å†› +1/+1 * ç­‰çº§' },
            'horse': { name: 'é©¬', emoji: 'ğŸ', tier: 1, atk: 2, hp: 1, desc: 'å‹å†›å¬å”¤: ç›´åˆ°æˆ˜æ–—ç»“æŸï¼Œä½¿å…¶ +1 æ”»å‡»åŠ› * ç­‰çº§' },
            'pig': { name: 'çŒª', emoji: 'ğŸ–', tier: 1, atk: 4, hp: 1, desc: 'å‡ºå”®: é¢å¤–è·å¾— 1 é‡‘å¸ * ç­‰çº§' },
            'duck': { name: 'é¸­å­', emoji: 'ğŸ¦†', tier: 1, atk: 2, hp: 3, desc: 'å‡ºå”®: ä½¿å•†åº—å® ç‰© +1 ç”Ÿå‘½å€¼ * ç­‰çº§' },
            
            'crab': { name: 'èƒèŸ¹', emoji: 'ğŸ¦€', tier: 2, atk: 3, hp: 1, desc: 'æˆ˜æ–—å¼€å§‹: å¤åˆ¶ç”Ÿå‘½å€¼æœ€é«˜çš„å‹å†› 50% ç”Ÿå‘½å€¼ * ç­‰çº§' },
            'dodo': { name: 'æ¸¡æ¸¡é¸Ÿ', emoji: 'ğŸ¦¤', tier: 2, atk: 2, hp: 3, desc: 'æˆ˜æ–—å¼€å§‹: ä½¿å‰æ–¹å‹å†›è·å¾—è‡ªèº« 50% æ”»å‡»åŠ› * ç­‰çº§' },
            'elephant': { name: 'å¤§è±¡', emoji: 'ğŸ˜', tier: 2, atk: 3, hp: 5, desc: 'æ”»å‡»å‰: å¯¹åæ–¹ 1/2/3 ä¸ªå‹å†›é€ æˆ 1 ç‚¹ä¼¤å®³' },
            'flamingo': { name: 'ç«çƒˆé¸Ÿ', emoji: 'ğŸ¦©', tier: 2, atk: 4, hp: 2, desc: 'æ˜å¥: ä½¿åæ–¹ä¸¤åªå‹å†› +1/+1 * ç­‰çº§' },
            'hedgehog': { name: 'åˆºçŒ¬', emoji: 'ğŸ¦”', tier: 2, atk: 3, hp: 2, desc: 'æ˜å¥: å¯¹æ‰€æœ‰å® ç‰©é€ æˆ 2 ç‚¹ä¼¤å®³ * ç­‰çº§' },
            'peacock': { name: 'å­”é›€', emoji: 'ğŸ¦š', tier: 2, atk: 2, hp: 5, desc: 'å—ä¼¤: è·å¾— +50% æ”»å‡»åŠ› * ç­‰çº§' },
            'rat': { name: 'è€é¼ ', emoji: 'ğŸ€', tier: 2, atk: 4, hp: 5, desc: 'æ˜å¥: åœ¨å¯¹æ–¹åœºä¸Šå¬å”¤ä¸€åª 1/1 è„è€é¼ ' },
            'dirty_rat': { name: 'è„è€é¼ ', emoji: 'ğŸ', tier: 1, atk: 1, hp: 1, desc: 'å æ®å¯¹æ‰‹çš„ä¸€ä¸ªä½ç½®', token: true },
            'spider': { name: 'èœ˜è››', emoji: 'ğŸ•·ï¸', tier: 2, atk: 2, hp: 2, desc: 'æ˜å¥: å¬å”¤ä¸€åªç­‰çº§ 1/2/3 çš„ 3 é˜¶å® ç‰©' },
            'swan': { name: 'å¤©é¹…', emoji: 'ğŸ¦¢', tier: 2, atk: 1, hp: 3, desc: 'å›åˆå¼€å§‹: è·å¾— 1 é‡‘å¸ * ç­‰çº§' },
            'shrimp': { name: 'è™¾', emoji: 'ğŸ¦', tier: 2, atk: 2, hp: 3, desc: 'å‹å†›å‡ºå”®: ä½¿ä¸€åªéšæœºå‹å†› +1 ç”Ÿå‘½å€¼ * ç­‰çº§' },

            'bee': { name: 'èœœèœ‚', emoji: 'ğŸ', tier: 1, atk: 1, hp: 1, desc: '', token: true },
            'ram': { name: 'å…¬ç¾Š', emoji: 'ğŸ', tier: 3, atk: 2, hp: 2, desc: '', token: true },
            
            // Tier 3
            'badger': { name: 'ç¾', emoji: 'ğŸ¦¡', tier: 3, atk: 5, hp: 4, desc: 'æ˜å¥: å¯¹ç›¸é‚»å® ç‰©é€ æˆæ”»å‡»åŠ›ä¼¤å®³' },
            'camel': { name: 'éª†é©¼', emoji: 'ğŸª', tier: 3, atk: 2, hp: 5, desc: 'å—ä¼¤: ä½¿åæ–¹å‹å†› +1/+2 * ç­‰çº§' },
            'giraffe': { name: 'é•¿é¢ˆé¹¿', emoji: 'ğŸ¦’', tier: 3, atk: 2, hp: 5, desc: 'å›åˆç»“æŸ: ä½¿å‰æ–¹å‹å†› +1/+1 * ç­‰çº§' },
            'kangaroo': { name: 'è¢‹é¼ ', emoji: 'ğŸ¦˜', tier: 3, atk: 1, hp: 2, desc: 'å‰æ–¹å‹å†›æ”»å‡»: è·å¾— +2/+2 * ç­‰çº§' },
            'ox': { name: 'å…¬ç‰›', emoji: 'ğŸ‚', tier: 3, atk: 1, hp: 4, desc: 'å‰æ–¹å‹å†›æ˜å¥: è·å¾—è¥¿ç“œç”²å¹¶ +2 æ”»å‡»åŠ› * ç­‰çº§' },
            'turtle': { name: 'æµ·é¾Ÿ', emoji: 'ğŸ¢', tier: 3, atk: 1, hp: 2, desc: 'æ˜å¥: ç»™åæ–¹ 1/2/3 åªå‹å†›è´´ä¸Šè¥¿ç“œç”²' },
            'rabbit': { name: 'å…”å­', emoji: 'ğŸ‡', tier: 3, atk: 3, hp: 2, desc: 'å‹å†›åƒé£Ÿç‰©: ä½¿å…¶ +1 ç”Ÿå‘½å€¼ * ç­‰çº§' },
            'sheep': { name: 'ç»µç¾Š', emoji: 'ğŸ‘', tier: 3, atk: 2, hp: 2, desc: 'æ˜å¥: å¬å”¤ä¸¤åª 2/2 å…¬ç¾Š' },
            'snail': { name: 'èœ—ç‰›', emoji: 'ğŸŒ', tier: 3, atk: 2, hp: 2, desc: 'è´­ä¹°: å¦‚æœä¸Šä¸€æˆ˜å¤±è´¥ï¼Œä½¿æ‰€æœ‰å‹å†› +1/+1 * ç­‰çº§' },
            'dog': { name: 'ç‹—', emoji: 'ğŸ•', tier: 3, atk: 3, hp: 3, desc: 'å‹å†›å¬å”¤: è·å¾— +1/+1 * ç­‰çº§' },
            'blowfish': { name: 'æ²³è±š', emoji: 'ğŸ¡', tier: 3, atk: 3, hp: 5, desc: 'å—ä¼¤: å¯¹ä¸€åªéšæœºæ•Œäººé€ æˆ 2 ç‚¹ä¼¤å®³ * ç­‰çº§' },
            'whale': { name: 'é²¸é±¼', emoji: 'ğŸ‹', tier: 3, atk: 3, hp: 8, desc: 'æˆ˜æ–—å¼€å§‹: åé£Ÿå‰æ–¹å‹å†›ï¼Œæ˜å¥æ—¶å°†å…¶åå‡º (ç­‰çº§ 1/2/3)' },

            // Tier 4
            'bison': { name: 'é‡ç‰›', emoji: 'ğŸ¦¬', tier: 4, atk: 4, hp: 4, desc: 'å›åˆç»“æŸ: å¦‚æœæœ‰ 3 çº§å‹å†›ï¼Œè·å¾— +2/+2 * ç­‰çº§' },
            'deer': { name: 'é¹¿', emoji: 'ğŸ¦Œ', tier: 4, atk: 1, hp: 1, desc: 'æ˜å¥: å¬å”¤ä¸€åª 5/5 çš„å·´å£«' },
            'bus': { name: 'å·´å£«', emoji: 'ğŸšŒ', tier: 1, atk: 5, hp: 5, desc: 'æ”»å‡»æ—¶å¯¹åæ–¹æ•Œäººé€ æˆä¼¤å®³', token: true },
            'dolphin': { name: 'æµ·è±š', emoji: 'ğŸ¬', tier: 4, atk: 4, hp: 6, desc: 'æˆ˜æ–—å¼€å§‹: å¯¹ç”Ÿå‘½å€¼æœ€ä½çš„æ•Œäººé€ æˆ 5 ç‚¹ä¼¤å®³ * ç­‰çº§' },
            'hippo': { name: 'æ²³é©¬', emoji: 'ğŸ¦›', tier: 4, atk: 4, hp: 7, desc: 'å‡»æ€: è·å¾— +3/+3 * ç­‰çº§' },
            'penguin': { name: 'ä¼é¹…', emoji: 'ğŸ§', tier: 4, atk: 1, hp: 2, desc: 'å›åˆç»“æŸ: ä½¿å…¶ä»–ç­‰çº§ 2 å’Œ 3 çš„å‹å†› +1/+1 * ç­‰çº§' },
            'rooster': { name: 'å…¬é¸¡', emoji: 'ğŸ“', tier: 4, atk: 5, hp: 3, desc: 'æ˜å¥: å¬å”¤ 1 åªæ”»å‡»åŠ›ä¸ºè‡ªèº« 50% çš„å°é¸¡ * ç­‰çº§' },
            'chick': { name: 'å°é¸¡', emoji: 'ğŸ£', tier: 1, atk: 1, hp: 1, desc: 'æ”»å‡»åŠ›ä¸ºå…¬é¸¡çš„ 50%', token: true },
            'skunk': { name: 'è‡­é¼¬', emoji: 'ğŸ¦¨', tier: 4, atk: 3, hp: 6, desc: 'æˆ˜æ–—å¼€å§‹: ä½¿ç”Ÿå‘½å€¼æœ€é«˜çš„æ•Œäººç”Ÿå‘½å€¼å‡å°‘ 33% * ç­‰çº§' },
            'worm': { name: 'è •è™«', emoji: 'ğŸª±', tier: 4, atk: 2, hp: 2, desc: 'åƒé£Ÿç‰©: è·å¾— +1/+1 * ç­‰çº§' },

            // Tier 5
            'cow': { name: 'å¥¶ç‰›', emoji: 'ğŸ„', tier: 5, atk: 4, hp: 6, desc: 'è´­ä¹°: å•†åº—é£Ÿç‰©å˜ä¸ºå…è´¹ç‰›å¥¶ (ç»™äºˆ +1/+2 * ç­‰çº§)' },
            'crocodile': { name: 'é³„é±¼', emoji: 'ğŸŠ', tier: 5, atk: 8, hp: 4, desc: 'æˆ˜æ–—å¼€å§‹: å¯¹æœ€åæ–¹æ•Œäººé€ æˆ 8 ç‚¹ä¼¤å®³ * ç­‰çº§' },
            'microbe': { name: 'å¾®ç”Ÿç‰©', emoji: 'ğŸ¦ ', tier: 5, atk: 1, hp: 1, desc: 'æˆ˜æ–—å¼€å§‹: ä½¿æ‰€æœ‰å® ç‰©å˜è™šå¼± (å—åˆ°çš„ä¼¤å®³ +3)' },
            'monkey': { name: 'çŒ´å­', emoji: 'ğŸ’', tier: 5, atk: 1, hp: 2, desc: 'å›åˆç»“æŸ: ä½¿æœ€å‰æ–¹çš„å‹å†› +2/+3 * ç­‰çº§' },
            'rhino': { name: 'çŠ€ç‰›', emoji: 'ğŸ¦', tier: 5, atk: 5, hp: 8, desc: 'å‡»æ€: å¯¹ç¬¬ä¸€ä¸ªæ•Œäººé€ æˆ 4 ç‚¹ä¼¤å®³ * ç­‰çº§' },
            'scorpion': { name: 'èå­', emoji: 'ğŸ¦‚', tier: 5, atk: 1, hp: 1, desc: 'æºå¸¦èŠ±ç”Ÿ: å¿…å®šå‡»æ€å—åˆ°ä¼¤å®³çš„æ•Œäºº', defaultItem: 'peanut' },
            'seal': { name: 'æµ·è±¹', emoji: 'ğŸ¦­', tier: 5, atk: 3, hp: 8, desc: 'åƒé£Ÿç‰©: ä½¿ä¸¤åªéšæœºå‹å†› +1/+1 * ç­‰çº§' },
            'shark': { name: 'é²¨é±¼', emoji: 'ğŸ¦ˆ', tier: 5, atk: 4, hp: 4, desc: 'å‹å†›æ˜å¥: è·å¾— +2/+2 * ç­‰çº§' },
            'turkey': { name: 'ç«é¸¡', emoji: 'ğŸ¦ƒ', tier: 5, atk: 3, hp: 4, desc: 'å‹å†›å¬å”¤: ä½¿å…¶ +3/+3 * ç­‰çº§' },
            'eagle': { name: 'è€é¹°', emoji: 'ğŸ¦…', tier: 5, atk: 3, hp: 1, desc: 'æ˜å¥: å¬å”¤ä¸€åª 6 é˜¶å® ç‰©' },

            // Tier 6
            'boar': { name: 'é‡çŒª', emoji: 'ğŸ—', tier: 6, atk: 10, hp: 6, desc: 'æ”»å‡»å‰: è·å¾— +4/+2 * ç­‰çº§' },
            'cat': { name: 'çŒ«', emoji: 'ğŸˆ', tier: 6, atk: 4, hp: 5, desc: 'é£Ÿç‰©æ•ˆæœ x2 (ç­‰çº§å½±å“å€ç‡? ä¸, çŒ«é€šå¸¸æ˜¯2/3/4å€)' }, // Simplify to x2/3/4
            'dragon': { name: 'é¾™', emoji: 'ğŸ‰', tier: 6, atk: 6, hp: 8, desc: 'è´­ä¹° 1 é˜¶å® ç‰©: ä½¿æ‰€æœ‰å‹å†› +1/+1 * ç­‰çº§' },
            'fly': { name: 'è‹è‡', emoji: 'ğŸª°', tier: 6, atk: 5, hp: 5, desc: 'å‹å†›æ˜å¥: åœ¨è¯¥ä½ç½®å¬å”¤ä¸€åª 5/5 è‹è‡ (æ¯åœºæˆ˜æ–—æœ€å¤š 3 æ¬¡)' },
            'zombie_fly': { name: 'åƒµå°¸è‹è‡', emoji: 'ğŸ¦Ÿ', tier: 1, atk: 5, hp: 5, desc: '', token: true },
            'gorilla': { name: 'å¤§çŒ©çŒ©', emoji: 'ğŸ¦', tier: 6, atk: 6, hp: 9, desc: 'å—ä¼¤: è·å¾—æ¤°å­ç”² (å…ç–« 1 æ¬¡ä¼¤å®³) (æ¯åœº 1 æ¬¡ * ç­‰çº§)' },
            'leopard': { name: 'è±¹å­', emoji: 'ğŸ†', tier: 6, atk: 10, hp: 4, desc: 'æˆ˜æ–—å¼€å§‹: å¯¹éšæœºæ•Œäººé€ æˆ 50% æ”»å‡»åŠ›ä¼¤å®³ * ç­‰çº§' },
            'mammoth': { name: 'çŒ›çŠ¸è±¡', emoji: 'ğŸ¦£', tier: 6, atk: 3, hp: 10, desc: 'æ˜å¥: ä½¿æ‰€æœ‰å‹å†› +2/+2 * ç­‰çº§' },
            'snake': { name: 'è›‡', emoji: 'ğŸ', tier: 6, atk: 6, hp: 6, desc: 'å‰æ–¹å‹å†›æ”»å‡»: å¯¹ä¸€åªéšæœºæ•Œäººé€ æˆ 5 ç‚¹ä¼¤å®³ * ç­‰çº§' },
            'tiger': { name: 'è€è™', emoji: 'ğŸ…', tier: 6, atk: 4, hp: 3, desc: 'å‰æ–¹å‹å†›åœ¨æˆ˜æ–—ä¸­é‡å¤é‡Šæ”¾æŠ€èƒ½' },
            'octopus': { name: 'ç« é±¼', emoji: 'ğŸ™', tier: 6, atk: 8, hp: 8, desc: 'æ”»å‡»å‰: å¯¹ä¸¤åªéšæœºæ•Œäººé€ æˆ 3/6/9 ç‚¹ä¼¤å®³' }
        };

        const FOOD_DATA = {
            'apple': { name: 'è‹¹æœ', emoji: 'ğŸ', cost: 3, desc: 'ä½¿ä¸€åªå® ç‰© +1/+1' },
            'honey': { name: 'èœ‚èœœ', emoji: 'ğŸ¯', cost: 3, desc: 'æ˜å¥: å¬å”¤ä¸€åª 1/1 èœœèœ‚' },
            'cupcake': { name: 'æ¯å­è›‹ç³•', emoji: 'ğŸ§', cost: 3, desc: 'ç›´åˆ°æˆ˜æ–—ç»“æŸï¼Œä½¿ä¸€åªå® ç‰© +3/+3' },
            'meat': { name: 'è‚‰éª¨å¤´', emoji: 'ğŸ–', cost: 3, desc: 'æ”»å‡»æ—¶é¢å¤–é€ æˆ 3 ç‚¹ä¼¤å®³' },
            'pill': { name: 'å®‰çœ è¯', emoji: 'ğŸ’Š', cost: 1, desc: 'ä½¿ä¸€åªå® ç‰©æ˜å¥ï¼ˆæ°¸ä¹…ï¼‰' },
            'salad': { name: 'æ²™æ‹‰', emoji: 'ğŸ¥—', cost: 3, desc: 'ä½¿ä¸¤åªéšæœºå® ç‰© +1/+1' },
            'garlic': { name: 'å¤§è’œ', emoji: 'ğŸ§„', cost: 3, desc: 'å—åˆ°çš„ä¼¤å®³å‡å°‘ 2 ç‚¹' },
            'chili': { name: 'è¾£æ¤’', emoji: 'ğŸŒ¶ï¸', cost: 3, desc: 'æ”»å‡»æ—¶å¯¹åæ–¹æ•Œäººé€ æˆ 5 ç‚¹ä¼¤å®³' },
            'chocolate': { name: 'å·§å…‹åŠ›', emoji: 'ğŸ«', cost: 3, desc: 'ä½¿ä¸€åªå® ç‰©è·å¾— +1 ç»éªŒå€¼' },
            'sushi': { name: 'å¯¿å¸', emoji: 'ğŸ£', cost: 3, desc: 'ä½¿ä¸‰åªéšæœºå® ç‰© +1/+1' },
            'melon': { name: 'è¥¿ç“œ', emoji: 'ğŸ‰', cost: 3, desc: 'å—åˆ°ä¼¤å®³æ—¶æŠµæ¶ˆ 20 ç‚¹ä¼¤å®³ (ä¸€æ¬¡æ€§)' },
            'mushroom': { name: 'è˜‘è‡', emoji: 'ğŸ„', cost: 3, desc: 'æ˜å¥: å¤æ´»ä¸º 1/1' },
            'steak': { name: 'ç‰›æ’', emoji: 'ğŸ¥©', cost: 3, desc: 'æ”»å‡»æ—¶é¢å¤–é€ æˆ 20 ç‚¹ä¼¤å®³ (ä¸€æ¬¡æ€§)' },
            'weakness': { name: 'è™šå¼±', emoji: 'ğŸ¦ ', cost: 0, desc: 'å—åˆ°çš„ä¼¤å®³ +3', token: true },
            'milk': { name: 'ç‰›å¥¶', emoji: 'ğŸ¥›', cost: 0, desc: 'ä½¿ä¸€åªå® ç‰© +1/+2', token: true },
            'coconut': { name: 'æ¤°å­', emoji: 'ğŸ¥¥', cost: 0, desc: 'å…ç–«ä¸€æ¬¡ä¼¤å®³', token: true },
            'peanut': { name: 'èŠ±ç”Ÿ', emoji: 'ğŸ¥œ', cost: 0, desc: 'å¿…å®šå‡»æ€å—åˆ°ä¼¤å®³çš„æ•Œäºº', token: true }
        };

        // --- Game Logic ---

        class Pet {
            constructor(id, dataId, xp = 0) {
                this.id = id || Math.random().toString(36).substr(2, 9);
                this.dataId = dataId;
                const data = PET_DATA[dataId];
                this.name = data.name;
                this.emoji = data.emoji;
                this.tier = data.tier;
                this.baseAtk = data.atk;
                this.baseHp = data.hp;
                this.atk = data.atk;
                this.hp = data.hp;
                this.xp = xp;
                this.level = this.getDisplayLevel();
                this.item = data.defaultItem || null;
                this.frozen = false;
                
                // Battle specific
                this.tempAtk = 0;
                this.tempHp = 0;
                this.levelOverride = null;
            }

            get totalAtk() { return Math.min(50, this.atk + this.tempAtk); }
            get totalHp() { return Math.min(50, this.hp + this.tempHp); }
            
            getDisplayLevel() {
                if (this.levelOverride) return this.levelOverride;
                if (this.xp >= 5) return 3;
                if (this.xp >= 2) return 2;
                return 1;
            }
        }

        class Game {
            constructor() {
                this.gold = 10;
                this.lives = 5;
                this.wins = 0;
                this.turn = 1;
                this.shopPets = [];
                this.shopFood = [];
                this.team = [null, null, null, null, null]; // Fixed 5 slots
                this.enemyTeam = [];
                
                this.selectedShopItem = null; // { type: 'pet'|'food', index: 0 }
                this.selectedTeamIndex = -1;
                this.state = 'shop'; // shop, battle, anim
                
                this.lastBattleResult = null; // win, loss, draw

                this.init();
            }

            init() {
                this.rollShop();
                this.onTurnStart();
                this.render();
                this.setupInputs();
            }

            // --- Shop Logic ---
            
            onTurnStart() {
                // Swan
                this.team.forEach(p => {
                    if (p && p.dataId === 'swan') {
                        this.gold += 1 * p.getDisplayLevel();
                    }
                });
                this.render();
            }

            onTurnEnd() {
                // End of Turn Triggers (Shop Phase)
                this.team.forEach((pet, index) => {
                     if (!pet) return;

                     // Giraffe: Buff friend ahead
                     if (pet.dataId === 'giraffe') {
                         if (index > 0 && this.team[index-1]) {
                             const friend = this.team[index-1];
                             friend.atk += 1 * pet.getDisplayLevel();
                             friend.hp += 1 * pet.getDisplayLevel();
                         }
                     }
                     // Monkey: Buff front-most friend
                     else if (pet.dataId === 'monkey') {
                         const frontFriend = this.team.find(p => p !== null);
                         if (frontFriend) {
                             frontFriend.atk += 2 * pet.getDisplayLevel();
                             frontFriend.hp += 3 * pet.getDisplayLevel();
                         }
                     }
                     // Bison: Self buff if lvl 3 friend exists
                     else if (pet.dataId === 'bison') {
                         const hasLvl3 = this.team.some(p => p && p !== pet && p.getDisplayLevel() === 3);
                         if (hasLvl3) {
                             pet.atk += 2 * pet.getDisplayLevel();
                             pet.hp += 2 * pet.getDisplayLevel();
                         }
                     }
                     // Penguin: Buff lvl 2/3 friends
                     else if (pet.dataId === 'penguin') {
                         this.team.forEach(friend => {
                             if (friend && friend !== pet && friend.getDisplayLevel() >= 2) {
                                 friend.atk += 1 * pet.getDisplayLevel();
                                 friend.hp += 1 * pet.getDisplayLevel();
                             }
                         });
                     }
                });
                this.render();
            }

            getShopTier() {
                if (this.turn >= 11) return 6;
                if (this.turn >= 9) return 5;
                if (this.turn >= 7) return 4;
                if (this.turn >= 5) return 3;
                if (this.turn >= 3) return 2;
                return 1;
            }

            rollShop() {
                if (this.gold < 1 && this.shopPets.length > 0) return; // Can't roll
                if (this.shopPets.length > 0) this.gold--; // Cost 1 to roll if not first load

                // Clear unfrozen
                this.shopPets = this.shopPets.filter(p => p.frozen);
                this.shopFood = this.shopFood.filter(f => f.frozen);

                const tier = this.getShopTier();
                const petCount = 3 + (tier >= 3 ? 1 : 0) + (tier >= 5 ? 1 : 0); // 3, 4, 5 slots
                const foodCount = 2;

                // Fill Pets
                while (this.shopPets.length < petCount) {
                    const availableTiers = [];
                    for(let t=1; t<=tier; t++) {
                        if(TIERS[t] && TIERS[t].pets.length > 0) availableTiers.push(t);
                    }
                    if (availableTiers.length === 0) availableTiers.push(1); // Fallback

                    const randomTier = availableTiers[Math.floor(Math.random() * availableTiers.length)];
                    const petsInTier = TIERS[randomTier].pets;
                    const randomPetId = petsInTier[Math.floor(Math.random() * petsInTier.length)];
                    this.shopPets.push(new Pet(null, randomPetId));
                }

                // Fill Food
                while (this.shopFood.length < foodCount) {
                    const foods = Object.keys(FOOD_DATA);
                    // Filter foods by tier? Simplified: all foods available for now or basic tier logic
                    // Let's just pick random food
                    const randomFood = foods[Math.floor(Math.random() * foods.length)];
                    this.shopFood.push({ id: randomFood, frozen: false });
                }

                this.render();
            }

            // --- Actions ---

            handleLevelUp(pet) {
                // 1. Generate Shop Reward (Next Tier Pet)
                const currentTier = this.getShopTier();
                const rewardTier = Math.min(6, currentTier + 1);
                
                // Add 2 choices from reward tier
                const petsInTier = TIERS[rewardTier].pets;
                if (petsInTier && petsInTier.length > 0) {
                     for(let k=0; k<2; k++) {
                         const randomPetId = petsInTier[Math.floor(Math.random() * petsInTier.length)];
                         const rewardPet = new Pet(null, randomPetId);
                         this.shopPets.push(rewardPet);
                     }
                }

                // 2. Fish Trigger
                if (pet.dataId === 'fish') {
                     this.team.forEach(friend => {
                         if (friend !== pet) {
                             friend.atk += 1 * pet.getDisplayLevel();
                             friend.hp += 1 * pet.getDisplayLevel();
                         }
                     });
                }
            }

            buyPet(shopIndex, teamIndex) {
                if (this.gold < 3) return;
                const pet = this.shopPets[shopIndex];
                
                // Merge logic
                if (this.team[teamIndex]) {
                    if (this.team[teamIndex].dataId === pet.dataId && this.team[teamIndex].xp < 5) {
                        // Merge
                        this.gold -= 3;
                        const target = this.team[teamIndex];
                        const oldLevel = target.getDisplayLevel();
                        
                        target.xp += 1;
                        target.atk += 1;
                        target.hp += 1;
                        
                        const newLevel = target.getDisplayLevel();
                        
                        // Level Up Trigger
                        if (newLevel > oldLevel) {
                            this.handleLevelUp(target);
                        }

                        this.shopPets.splice(shopIndex, 1);
                        return;
                    } 
                    
                    // Insertion Logic: If occupied and not merge, try to shift pets to make room
                    let emptyIndex = -1;
                    let minDist = 999;
                    
                    for(let i=0; i<5; i++) {
                        if (this.team[i] === null) {
                            const dist = Math.abs(i - teamIndex);
                            if (dist < minDist) {
                                minDist = dist;
                                emptyIndex = i;
                            }
                        }
                    }
                    
                    if (emptyIndex !== -1) {
                        if (emptyIndex > teamIndex) {
                            // Shift Right
                            for (let k = emptyIndex; k > teamIndex; k--) {
                                this.team[k] = this.team[k-1];
                            }
                        } else {
                            // Shift Left
                            for (let k = emptyIndex; k < teamIndex; k++) {
                                this.team[k] = this.team[k+1];
                            }
                        }
                        this.team[teamIndex] = null; // Slot is now available
                    } else {
                        return; // No space to insert
                    }
                }

                // Place in empty slot
                if (teamIndex >= 0 && teamIndex < 5 && !this.team[teamIndex]) {
                    this.gold -= 3;
                    this.team[teamIndex] = pet;
                    this.shopPets.splice(shopIndex, 1);

                    // Dragon Trigger (Buy Tier 1)
                    if (pet.tier === 1) {
                        this.team.forEach(p => {
                            if (p && p.dataId === 'dragon') {
                                this.team.forEach(friend => {
                                    if (friend && friend !== p) {
                                        friend.atk += 1 * p.getDisplayLevel();
                                        friend.hp += 1 * p.getDisplayLevel();
                                    }
                                });
                            }
                        });
                    }

                    // On Buy Triggers (Self)
                    if (pet.dataId === 'otter') {
                        const friends = this.team.filter(p => p && p !== pet);
                        if (friends.length > 0) {
                            const friend = friends[Math.floor(Math.random() * friends.length)];
                            friend.atk += 1 * pet.getDisplayLevel();
                            friend.hp += 1 * pet.getDisplayLevel();
                        }
                    } else if (pet.dataId === 'snail') {
                        if (this.lastBattleResult === 'loss') {
                             this.team.forEach(p => {
                                 if (p && p !== pet) {
                                     p.atk += 1 * pet.getDisplayLevel();
                                     p.hp += 1 * pet.getDisplayLevel();
                                 }
                             });
                        }
                    } else if (pet.dataId === 'cow') {
                        // Cow: Replace shop food with 2 free Milk
                        this.shopFood = [
                            { id: 'milk', frozen: false },
                            { id: 'milk', frozen: false }
                        ];
                    }

                    // On Friend Summoned Triggers (e.g., Horse, Dog)
                    this.team.forEach(p => {
                        if (p && p !== pet) {
                            if (p.dataId === 'horse') {
                                pet.tempAtk += 1 * p.getDisplayLevel();
                            } else if (p.dataId === 'dog') {
                                p.atk += 1 * p.getDisplayLevel();
                                p.hp += 1 * p.getDisplayLevel();
                            }
                        }
                    });
                }
                this.render();
            }
            
            buyFood(shopIndex, teamIndex) {
                if (this.gold < FOOD_DATA[this.shopFood[shopIndex].id].cost) return;
                if (!this.team[teamIndex]) return;

                const foodId = this.shopFood[shopIndex].id;
                const pet = this.team[teamIndex];
                const cost = FOOD_DATA[foodId].cost;

                this.gold -= cost;
                this.shopFood.splice(shopIndex, 1);

                // Calculate Multiplier (Cat)
                let multiplier = 1;
                this.team.forEach(p => {
                    if (p && p.dataId === 'cat') multiplier += p.getDisplayLevel();
                });
                
                const statBoost = (val) => val * multiplier;

                if (foodId === 'apple') {
                    pet.atk += statBoost(1);
                    pet.hp += statBoost(1);
                } else if (foodId === 'cupcake') {
                    pet.tempAtk += statBoost(3);
                    pet.tempHp += statBoost(3);
                } else if (foodId === 'meat') {
                    pet.item = 'meat';
                } else if (foodId === 'honey') {
                    pet.item = 'honey';
                } else if (foodId === 'garlic') {
                    pet.item = 'garlic';
                } else if (foodId === 'chili') {
                    pet.item = 'chili';
                } else if (foodId === 'melon') {
                    pet.item = 'melon';
                } else if (foodId === 'mushroom') {
                    pet.item = 'mushroom';
                } else if (foodId === 'steak') {
                    pet.item = 'steak';
                } else if (foodId === 'chocolate') {
                     const oldLevel = pet.getDisplayLevel();
                     pet.xp += 1;
                     pet.level = pet.getDisplayLevel();
                     if (pet.getDisplayLevel() > oldLevel) {
                         this.handleLevelUp(pet);
                     }
                } else if (foodId === 'sushi') {
                    const targets = this.team.filter(p => p !== null);
                    for(let k=0; k<3; k++) {
                        if(targets.length > 0) {
                            const r = Math.floor(Math.random()*targets.length);
                            targets[r].atk += statBoost(1);
                            targets[r].hp += statBoost(1);
                            targets.splice(r, 1);
                        }
                    }
                } else if (foodId === 'salad') {
                    const targets = this.team.filter(p => p !== null);
                     for(let k=0; k<2; k++) {
                        if(targets.length > 0) {
                            const r = Math.floor(Math.random()*targets.length);
                            targets[r].atk += statBoost(1);
                            targets[r].hp += statBoost(1);
                            targets.splice(r, 1);
                        }
                    }
                } else if (foodId === 'milk') {
                    pet.atk += statBoost(1);
                    pet.hp += statBoost(2);
                } else if (foodId === 'coconut') {
                    pet.item = 'coconut'; 
                } else if (foodId === 'pill') {
                    const deadPet = this.team[teamIndex];
                    this.team[teamIndex] = null;
                    
                    // Trigger Faint (Permanent)
                    if (deadPet.dataId === 'ant') {
                         const friends = this.team.filter(p => p !== null);
                         if (friends.length > 0) {
                             const f = friends[Math.floor(Math.random() * friends.length)];
                             f.atk += 2 * deadPet.getDisplayLevel();
                             f.hp += 1 * deadPet.getDisplayLevel();
                         }
                    } else if (deadPet.dataId === 'flamingo') {
                         for (let k=1; k<=2; k++) {
                             if (teamIndex + k < this.team.length && this.team[teamIndex + k]) {
                                 const f = this.team[teamIndex + k];
                                 f.atk += 1 * deadPet.getDisplayLevel();
                                 f.hp += 1 * deadPet.getDisplayLevel();
                             }
                         }
                    } else if (deadPet.dataId === 'mammoth') {
                         this.team.forEach(p => {
                             if (p) {
                                 p.atk += 2 * deadPet.getDisplayLevel();
                                 p.hp += 2 * deadPet.getDisplayLevel();
                             }
                         });
                    } else if (deadPet.dataId === 'spider') {
                        // Spawn random Tier 3
                        const tier3Pets = TIERS[3].pets;
                        const randomId = tier3Pets[Math.floor(Math.random() * tier3Pets.length)];
                        const summon = new Pet(null, randomId);
                        summon.atk = 2; summon.hp = 2; 
                        summon.xp = (deadPet.getDisplayLevel() === 3 ? 5 : (deadPet.getDisplayLevel() === 2 ? 2 : 0));
                        summon.level = deadPet.getDisplayLevel();
                        this.team[teamIndex] = summon;
                    } else if (deadPet.dataId === 'eagle') {
                        const tier6Pets = TIERS[6].pets;
                        if (tier6Pets && tier6Pets.length > 0) {
                             const randomId = tier6Pets[Math.floor(Math.random() * tier6Pets.length)];
                             const summon = new Pet(null, randomId);
                             const d = PET_DATA[randomId];
                             summon.atk = d.atk; summon.hp = d.hp;
                             summon.xp = (deadPet.getDisplayLevel() === 3 ? 5 : (deadPet.getDisplayLevel() === 2 ? 2 : 0));
                             summon.level = deadPet.getDisplayLevel();
                             this.team[teamIndex] = summon;
                        }
                    } else if (deadPet.dataId === 'deer') {
                        const summon = new Pet(null, 'bus');
                        summon.atk = 5 * deadPet.getDisplayLevel();
                        summon.hp = 5 * deadPet.getDisplayLevel();
                        summon.item = 'chili';
                        this.team[teamIndex] = summon;
                    } else if (deadPet.dataId === 'turtle') {
                        const count = deadPet.getDisplayLevel();
                        for (let k = 1; k <= count; k++) {
                            if (teamIndex + k < this.team.length && this.team[teamIndex + k]) {
                                this.team[teamIndex + k].item = 'melon';
                            }
                        }
                    }
                    // Rabbit triggers on food eat? Yes.
                }

                // Worm Logic
                if (pet.dataId === 'worm') {
                    const buff = 1 * pet.getDisplayLevel();
                    pet.atk += buff;
                    pet.hp += buff;
                }

                // Seal Logic
                if (pet.dataId === 'seal') {
                    const friends = this.team.filter(p => p && p !== pet);
                    if (friends.length > 0) {
                        const targets = [];
                        const indices = friends.map((_, i) => i);
                        // Pick 2
                        for(let k=0; k<2; k++) {
                             if(indices.length === 0) break;
                             const r = Math.floor(Math.random() * indices.length);
                             targets.push(friends[indices[r]]);
                             indices.splice(r, 1);
                        }
                        
                        targets.forEach(t => {
                            t.atk += 1 * pet.getDisplayLevel();
                            t.hp += 1 * pet.getDisplayLevel();
                        });
                    }
                }
                
                // Rabbit Check
                if (foodId !== 'pill') { // Pill kills, so rabbit might not trigger on dead? Or triggers before?
                    // Rabbit says "Friend eats food".
                    this.team.forEach(p => {
                        if (p && p !== pet && p.dataId === 'rabbit') {
                            pet.hp += 1 * p.getDisplayLevel();
                        }
                    });
                }

                this.render();
            }

            sellPet(index) {
                const pet = this.team[index];
                if (!pet) return;

                let refund = pet.getDisplayLevel();
                if (pet.dataId === 'pig') refund += pet.getDisplayLevel();
                
                if (pet.dataId === 'beaver') {
                    const friends = this.team.filter((p, i) => p && i !== index);
                    for (let k=0; k<2; k++) {
                        if(friends.length > 0) {
                            const r = Math.floor(Math.random()*friends.length);
                            friends[r].hp += 1 * pet.getDisplayLevel();
                        }
                    }
                }
                
                if (pet.dataId === 'duck') {
                    this.shopPets.forEach(p => p.hp += 1 * pet.getDisplayLevel());
                }
                
                // Trigger Shrimp
                this.team.forEach(p => {
                    if (p && p !== pet && p.dataId === 'shrimp') {
                        const friends = this.team.filter(f => f && f !== pet && f !== p);
                        if (friends.length > 0) {
                            friends[Math.floor(Math.random() * friends.length)].hp += 1 * p.getDisplayLevel();
                        }
                    }
                });

                this.gold += refund;
                this.team[index] = null;
                this.selectedTeamIndex = -1;
                this.render();
            }

            freezeShopItem(type, index) {
                if (type === 'pet') {
                    this.shopPets[index].frozen = !this.shopPets[index].frozen;
                } else {
                    this.shopFood[index].frozen = !this.shopFood[index].frozen;
                }
                this.render();
            }

            movePet(fromIndex, toIndex) {
                if (toIndex < 0 || toIndex >= 5 || fromIndex === toIndex) return;
                
                const source = this.team[fromIndex];
                if (!source) return;

                const target = this.team[toIndex];
                
                if (target && target.dataId === source.dataId && target.xp < 5) {
                    // Merge logic
                    const oldLevel = target.getDisplayLevel();
                    
                    // SAP Merge: +1/+1 and gain XP
                    target.xp = Math.min(5, target.xp + source.xp + 1);
                    target.atk = Math.max(target.atk, source.atk) + 1;
                    target.hp = Math.max(target.hp, source.hp) + 1;
                    
                    if (target.getDisplayLevel() > oldLevel) {
                        this.handleLevelUp(target);
                    }
                    this.team[fromIndex] = null;
                } else {
                    // Swap logic
                    this.team[toIndex] = source;
                    this.team[fromIndex] = target;
                }
                
                this.render();
            }

            startBattle() {
                this.onTurnEnd();
                this.state = 'battle';
                this.enemyTeam = this.generateEnemyTeam();
                
                this.battleTeam = this.cloneTeam(this.team);
                this.battleEnemyTeam = this.cloneTeam(this.enemyTeam);
                
                this.render();
                
                setTimeout(() => {
                    new Battle(this, this.battleTeam, this.battleEnemyTeam).run();
                }, 1000);
            }

            cloneTeam(team) {
                return team
                    .filter(p => p !== null) // Only clone actual pets
                    .map(p => {
                        const np = new Pet(null, p.dataId, p.xp);
                        np.atk = p.atk;
                        np.hp = p.hp;
                        np.item = p.item;
                        np.atk += p.tempAtk;
                        np.hp += p.tempHp;
                        return np;
                    });
            }

            generateEnemyTeam() {
                const team = [];
                const size = Math.min(5, Math.ceil(this.turn / 2) + 2);
                const tier = Math.min(6, Math.floor(this.turn / 2) + 1);
                
                for(let i=0; i<size; i++) {
                     const availableTiers = [];
                    for(let t=1; t<=tier; t++) if(TIERS[t] && TIERS[t].pets.length > 0) availableTiers.push(t);
                    if(availableTiers.length === 0) availableTiers.push(1);
                    
                    const randomTier = availableTiers[Math.floor(Math.random() * availableTiers.length)];
                    const petsInTier = TIERS[randomTier].pets;
                    const randomPetId = petsInTier[Math.floor(Math.random() * petsInTier.length)];
                    const p = new Pet(null, randomPetId);
                    p.atk += Math.floor(this.turn * 0.5);
                    p.hp += Math.floor(this.turn * 0.5);
                    team.push(p);
                }
                return team;
            }

            endBattle(result) {
                this.lastBattleResult = result;
                if (result === 'win') {
                    this.wins++;
                } else if (result === 'loss') {
                    this.lives--;
                }
                
                this.turn++;
                this.gold = 10;
                
                // Reset temps
                this.team.forEach(p => {
                    if (p) {
                        p.tempAtk = 0;
                        p.tempHp = 0;
                    }
                });

                this.onTurnStart();
                
                if (this.lives <= 0) {
                    alert('æ¸¸æˆç»“æŸ! ä½ è¾“äº†ã€‚');
                    location.reload();
                } else if (this.wins >= 10) {
                    alert('æ­å–œ! ä½ èµ¢å¾—äº†10åœºèƒœåˆ©!');
                    location.reload();
                } else {
                    this.state = 'shop';
                    this.rollShop(); 
                    // render is called in rollShop
                }
            }
            
            render() {
                renderGame(this);
            }
            
            setupInputs() {
            }
        }

        // --- Battle Engine ---

        class Battle {
            constructor(game, myTeam, enemyTeam) {
                this.game = game;
                this.myTeam = myTeam;
                this.enemyTeam = enemyTeam;
                this.log = [];
            }

            async run() {
                // Start of Battle Triggers
                await this.triggerAbility('start_of_battle', this.myTeam, this.enemyTeam);
                await this.triggerAbility('start_of_battle', this.enemyTeam, this.myTeam);

                // Battle Loop
                while (this.myTeam.length > 0 && this.enemyTeam.length > 0) {
                    await this.battleRound();
                }

                // End
                let result = 'draw';
                if (this.myTeam.length > 0) result = 'win';
                if (this.enemyTeam.length > 0) result = 'loss';
                
                let resultText = "å¹³å±€!";
                if (result === 'win') resultText = "èƒœåˆ©!";
                if (result === 'loss') resultText = "å¤±è´¥!";

                showOverlay(resultText);
                setTimeout(() => {
                    this.game.endBattle(result);
                }, 2000);
            }

            async battleRound() {
                const p1 = this.myTeam[0];
                const p2 = this.enemyTeam[0];

                // Before Attack Triggers
                await this.triggerAbility('before_attack', this.myTeam, this.enemyTeam, p1);
                await this.triggerAbility('before_attack', this.enemyTeam, this.myTeam, p2);

                // Friend Ahead Attack Triggers (Kangaroo, Snake)
                // Trigger for pets behind p1/p2
                await this.triggerAbility('friend_ahead_attack', this.myTeam, this.enemyTeam, p1);
                await this.triggerAbility('friend_ahead_attack', this.enemyTeam, this.myTeam, p2);

                await playAttackAnim(p1, p2);

                let dmg1 = p1.totalAtk;
                let dmg2 = p2.totalAtk;
                
                // Steak Logic
                if (p1.item === 'steak') { dmg1 += 20; p1.item = null; }
                if (p2.item === 'steak') { dmg2 += 20; p2.item = null; }

                if (p1.item === 'meat') dmg1 += 3;
                if (p2.item === 'meat') dmg2 += 3;

                // Calculate actual damage (before applying)
                let actualDmgToP1 = dmg2;
                let actualDmgToP2 = dmg1;

                if (p1.item === 'garlic') actualDmgToP1 = Math.max(1, actualDmgToP1 - 2);
                if (p1.item === 'weakness') actualDmgToP1 += 3;
                if (p1.item === 'melon') {
                    actualDmgToP1 = Math.max(0, actualDmgToP1 - 20);
                    p1.item = null;
                }
                if (p1.item === 'coconut') {
                    actualDmgToP1 = 0;
                    p1.item = null;
                }
                
                if (p2.item === 'garlic') actualDmgToP2 = Math.max(1, actualDmgToP2 - 2);
                if (p2.item === 'weakness') actualDmgToP2 += 3;
                if (p2.item === 'melon') {
                    actualDmgToP2 = Math.max(0, actualDmgToP2 - 20);
                    p2.item = null;
                }
                if (p2.item === 'coconut') {
                    actualDmgToP2 = 0;
                    p2.item = null;
                }

                // Peanut Logic
                if (p1.item === 'peanut' && actualDmgToP2 > 0) actualDmgToP2 = 9999;
                if (p2.item === 'peanut' && actualDmgToP1 > 0) actualDmgToP1 = 9999;

                // Chili Logic
                if (p1.item === 'chili') {
                    if (this.enemyTeam.length > 1) {
                        const target = this.enemyTeam[1];
                        let splash = 5;
                        if (target.item === 'garlic') splash = Math.max(1, splash - 2);
                        if (target.item === 'melon') { splash = Math.max(0, splash - 20); target.item = null; }
                        target.hp -= splash;
                        showDamage(target, splash);
                    }
                }
                if (p2.item === 'chili') {
                    if (this.myTeam.length > 1) {
                        const target = this.myTeam[1];
                        let splash = 5;
                        if (target.item === 'garlic') splash = Math.max(1, splash - 2);
                        if (target.item === 'melon') { splash = Math.max(0, splash - 20); target.item = null; }
                        target.hp -= splash;
                        showDamage(target, splash);
                    }
                }

                p1.hp -= actualDmgToP1;
                p2.hp -= actualDmgToP2;

                showDamage(p1, actualDmgToP1);
                showDamage(p2, actualDmgToP2);
                
                renderBattleTeams(this.myTeam, this.enemyTeam);
                await sleep(500);

                // Hurt Triggers
                if (dmg2 > 0 && p1.hp > 0) await this.triggerAbility('hurt', this.myTeam, this.enemyTeam, p1);
                if (dmg1 > 0 && p2.hp > 0) await this.triggerAbility('hurt', this.enemyTeam, this.myTeam, p2);

                // Faint Check
                const fainted1 = p1.hp <= 0;
                const fainted2 = p2.hp <= 0;

                // Knock Out Triggers
                if (fainted1 && !fainted2) await this.triggerAbility('knock_out', this.enemyTeam, this.myTeam, p2);
                if (fainted2 && !fainted1) await this.triggerAbility('knock_out', this.myTeam, this.enemyTeam, p1);

                if (fainted1) await this.handleFaint(this.myTeam, 0, this.enemyTeam);
                if (fainted2) await this.handleFaint(this.enemyTeam, 0, this.myTeam);
            }

            async handleFaint(team, index, otherTeam) {
                const pet = team[index];
                
                let tigerLevel = 0;
                if (index + 1 < team.length) {
                    const behind = team[index+1];
                    if (behind && behind.dataId === 'tiger') {
                        tigerLevel = behind.getDisplayLevel();
                    }
                }
                const loops = 1 + (tigerLevel > 0 ? 1 : 0);
                
                const petSummons = [];
                const itemSummons = [];

                // --- Pet Ability Loop ---
                for (let i = 0; i < loops; i++) {
                     if (i === 1) pet.levelOverride = tigerLevel;

                     let s = null;
                     if (pet.dataId === 'cricket') {
                         s = new Pet(null, 'zombie_cricket');
                         s.atk = 1 * pet.getDisplayLevel();
                         s.hp = 1 * pet.getDisplayLevel();
                     } else if (pet.dataId === 'spider') {
                         const tier3Pets = TIERS[3].pets;
                         const randomId = tier3Pets[Math.floor(Math.random() * tier3Pets.length)];
                         s = new Pet(null, randomId);
                         s.atk = 2; s.hp = 2; 
                         s.xp = (pet.getDisplayLevel() === 3 ? 5 : (pet.getDisplayLevel() === 2 ? 2 : 0));
                         s.level = pet.getDisplayLevel();
                     } else if (pet.dataId === 'deer') {
                         s = new Pet(null, 'bus');
                         s.atk = 5 * pet.getDisplayLevel();
                         s.hp = 5 * pet.getDisplayLevel();
                         s.item = 'chili'; 
                     } else if (pet.dataId === 'eagle') {
                          const tier6Pets = TIERS[6].pets;
                          if (tier6Pets && tier6Pets.length > 0) {
                              const randomId = tier6Pets[Math.floor(Math.random() * tier6Pets.length)];
                              s = new Pet(null, randomId);
                              const d = PET_DATA[randomId];
                              s.atk = d.atk; s.hp = d.hp;
                              s.xp = (pet.getDisplayLevel() === 3 ? 5 : (pet.getDisplayLevel() === 2 ? 2 : 0));
                              s.level = pet.getDisplayLevel();
                          }
                     } else if (pet.dataId === 'whale' && pet.swallowedPet) {
                         const saved = pet.swallowedPet;
                         s = new Pet(null, saved.dataId);
                         const d = PET_DATA[saved.dataId];
                         s.atk = d.atk; s.hp = d.hp;
                         const lvl = pet.getDisplayLevel();
                         s.xp = (lvl === 3 ? 5 : (lvl === 2 ? 2 : 0));
                         s.level = lvl;
                     }
                     
                     if (s) petSummons.push(s);

                     if (pet.dataId === 'sheep') {
                         const ram1 = new Pet(null, 'ram');
                         ram1.atk = 2 * pet.getDisplayLevel(); ram1.hp = 2 * pet.getDisplayLevel();
                         const ram2 = new Pet(null, 'ram');
                         ram2.atk = 2 * pet.getDisplayLevel(); ram2.hp = 2 * pet.getDisplayLevel();
                         petSummons.push(ram1, ram2);
                     }
                     
                     if (pet.dataId === 'rooster') {
                         const chick = new Pet(null, 'chick');
                         chick.atk = Math.max(1, Math.floor(pet.atk * 0.5));
                         chick.hp = 1;
                         petSummons.push(chick);
                     }
                     
                     if (pet.dataId === 'rat') {
                         if (otherTeam.length < 5) {
                              const dr = new Pet(null, 'dirty_rat');
                              otherTeam.unshift(dr);
                              if (otherTeam.length > 5) otherTeam.pop();
                         }
                     }
                     
                     if (pet.dataId === 'turtle') {
                         const count = pet.getDisplayLevel();
                         for (let k = 1; k <= count; k++) {
                             if (index + k < team.length) {
                                 team[index + k].item = 'melon';
                             }
                         }
                     }

                     await this.triggerSpecificAbility(pet, 'faint', team, otherTeam);
                     
                     if (i === 1) pet.levelOverride = null;
                }

                // --- Item Logic (Once) ---
                if (pet.item === 'honey') {
                     const bee = new Pet(null, 'bee');
                     itemSummons.push(bee);
                }
                if (pet.item === 'mushroom') {
                    const revived = new Pet(null, pet.dataId);
                    revived.atk = 1; revived.hp = 1;
                    revived.xp = pet.xp;
                    revived.level = pet.getDisplayLevel();
                    revived.item = null;
                    itemSummons.push(revived);
                }
                
                // --- Apply Summons ---
                const allSummons = [...petSummons, ...itemSummons];
                const space = 5 - (team.length - 1);
                
                if (allSummons.length > 0 && space > 0) {
                    const toAdd = allSummons.slice(0, space);
                    team.splice(index, 1, ...toAdd);
                    for(const s of toAdd) {
                        await this.triggerAbility('summoned', team, otherTeam, s);
                    }
                } else {
                    team.splice(index, 1);
                }
                
                // Fly Check (Global check after any faint)
                const flies = team.filter(p => p.dataId === 'fly');
                if (flies.length > 0) {
                    for(const fly of flies) {
                        if (!fly.flyUses) fly.flyUses = 0;
                        if (fly.flyUses < 3 * fly.getDisplayLevel() && team.length < 5) { 
                            const zf = new Pet(null, 'zombie_fly');
                            zf.atk = 5 * fly.getDisplayLevel();
                            zf.hp = 5 * fly.getDisplayLevel();
                            // Insert where friend died.
                            // If summons filled the spot, insert after them?
                            // Usually Fly summons at the spot of death.
                            // If death spot is occupied by summons (e.g. Cricket -> Zombie), Fly summons BEHIND Zombie?
                            // Or does Fly summon trigger first?
                            // "Friend faints -> Summon Zombie Fly".
                            // "Cricket Faints -> Summon Zombie Cricket".
                            // Order: Attack.
                            // If Fly has higher attack than Cricket?
                            // Complex.
                            // Simplified: Insert at `index` (pushing others back).
                            // `index` is now the start of new summons (if any).
                            // If we added summons, `index` points to the first summon.
                            // Fly should spawn there?
                            // Let's spawn at `index`.
                            if (team.length < 5) {
                                team.splice(index, 0, zf);
                                fly.flyUses++;
                                await this.triggerAbility('summoned', team, otherTeam, zf);
                                break; 
                            }
                        }
                    }
                }
                
                renderBattleTeams(this.myTeam, this.enemyTeam);
                await sleep(500);
            }

            async triggerAbility(trigger, team, otherTeam, specificPet = null) {
                // Create a copy for iteration to handle team mutations (e.g. Whale swallowing)
                // Sort by attack for start_of_battle? SAP does this.
                let pets = [...team];
                
                if (trigger === 'start_of_battle') {
                    // Sort by Attack Descending, then by HP Descending, then by Position (Index)
                    // Note: In SAP, position is tie-breaker.
                    pets.sort((a, b) => {
                        if (a.totalAtk !== b.totalAtk) return b.totalAtk - a.totalAtk;
                        if (a.totalHp !== b.totalHp) return b.totalHp - a.totalHp;
                        return team.indexOf(a) - team.indexOf(b);
                    });
                }

                for (const pet of pets) {
                    // Check if pet is still in team (might be swallowed or killed)
                    if (!team.includes(pet)) continue;
                    
                    // Dead pets don't trigger most abilities (except Faint, which is handled separately)
                    // But 'start_of_battle' pets should be alive.
                    if (pet.hp <= 0 && trigger !== 'faint' && trigger !== 'friend_faints') continue;

                    if (['before_attack', 'hurt'].includes(trigger)) {
                         if (specificPet && pet !== specificPet) continue;
                    }
                    await this.triggerSpecificAbility(pet, trigger, team, otherTeam, specificPet);

                    // Tiger Logic (Friend behind repeats ability)
                    // Need to find the pet currently behind 'pet' in the *current* team
                    const currentIdx = team.indexOf(pet);
                    if (currentIdx !== -1 && currentIdx + 1 < team.length) {
                        const petBehind = team[currentIdx + 1];
                        if (petBehind && petBehind.dataId === 'tiger') {
                            pet.levelOverride = petBehind.getDisplayLevel();
                            await this.triggerSpecificAbility(pet, trigger, team, otherTeam, specificPet);
                            pet.levelOverride = null;
                        }
                    }
                }
            }
            
            async triggerSpecificAbility(pet, trigger, team, otherTeam, contextPet = null) {
                const data = PET_DATA[pet.dataId];
                if (!data) return;
                
                if (trigger === 'summoned') {
                    if (pet.dataId === 'horse' && pet !== contextPet) { 
                         if (contextPet) {
                             contextPet.tempAtk += 1 * pet.getDisplayLevel();
                         }
                    } else if (pet.dataId === 'dog' && pet !== contextPet) {
                        pet.atk += 1 * pet.getDisplayLevel();
                        pet.hp += 1 * pet.getDisplayLevel();
                    } else if (pet.dataId === 'turkey' && pet !== contextPet) {
                        if (contextPet) {
                            contextPet.atk += 3 * pet.getDisplayLevel();
                            contextPet.hp += 3 * pet.getDisplayLevel();
                        }
                    }
                }
                
                if (trigger === 'hurt') {
                    if (pet.dataId === 'gorilla') {
                        if (!pet.gorillaTriggered) {
                            pet.item = 'coconut';
                            pet.gorillaTriggered = true;
                        }
                    }
                }
                
                if (trigger === 'start_of_battle') {
                    if (pet.dataId === 'mosquito') {
                        const num = pet.getDisplayLevel();
                        for(let k=0; k<num; k++) {
                            if (otherTeam.length > 0) {
                                const alive = otherTeam.filter(p => p.hp > 0);
                                if (alive.length > 0) {
                                    const target = alive[Math.floor(Math.random() * alive.length)];
                                    target.hp -= 1;
                                    showDamage(target, 1);
                                    createProjectile(pet, target, 'rock');
                                    await sleep(200);
                                }
                            }
                        }
                    } else if (pet.dataId === 'crab') {
                        const idx = team.indexOf(pet);
                        // Copy max HP friend
                        let maxHp = 0;
                        team.forEach(p => { if (p !== pet) maxHp = Math.max(maxHp, p.totalHp); });
                        if (maxHp > 0) {
                            pet.hp = Math.floor(maxHp * (0.5 * pet.getDisplayLevel())); 
                        }
                    } else if (pet.dataId === 'dodo') {
                         const idx = team.indexOf(pet);
                         if (idx > 0) {
                             const friend = team[idx-1];
                             friend.atk += Math.floor(pet.totalAtk * (0.5 * pet.getDisplayLevel()));
                         }
                    } else if (pet.dataId === 'skunk') {
                        if (otherTeam.length > 0) {
                            // Highest HP enemy
                            let target = otherTeam[0];
                            let maxHp = -1;
                            otherTeam.forEach(p => {
                                if (p.hp > maxHp && p.hp > 0) { maxHp = p.hp; target = p; }
                            });
                            
                            if (target) {
                                target.hp = Math.max(1, Math.floor(target.hp * (1 - 0.33 * pet.getDisplayLevel())));
                                showDamage(target, 0); 
                            }
                        }
                    } else if (pet.dataId === 'dolphin') {
                         if (otherTeam.length > 0) {
                            // Lowest HP enemy
                            let target = otherTeam[0];
                            let minHp = 9999;
                            otherTeam.forEach(p => {
                                if (p.hp < minHp && p.hp > 0) { minHp = p.hp; target = p; }
                            });
                            
                            if (target) {
                                const dmg = 5 * pet.getDisplayLevel();
                                target.hp -= dmg;
                                showDamage(target, dmg);
                                createProjectile(pet, target, 'rock');
                            }
                         }
                    } else if (pet.dataId === 'crocodile') {
                         if (otherTeam.length > 0) {
                             const target = otherTeam[otherTeam.length - 1];
                             const dmg = 8 * pet.getDisplayLevel();
                             target.hp -= dmg;
                             showDamage(target, dmg);
                             createProjectile(pet, target, 'rock');
                         }
                    } else if (pet.dataId === 'leopard') {
                        if (otherTeam.length > 0) {
                            // Deal 50% Attack to level targets
                            const targets = [];
                            const count = pet.getDisplayLevel();
                            const indices = otherTeam.map((_, i) => i);
                            for(let i=0; i<count; i++) {
                                if (indices.length === 0) break;
                                const rnd = Math.floor(Math.random() * indices.length);
                                const idx = indices.splice(rnd, 1)[0];
                                targets.push(otherTeam[idx]);
                            }

                            targets.forEach(target => {
                                const dmg = Math.floor(pet.totalAtk * 0.5);
                                target.hp -= dmg;
                                showDamage(target, dmg);
                                createProjectile(pet, target, 'rock');
                            });
                        }
                    } else if (pet.dataId === 'whale') {
                        const idx = team.indexOf(pet);
                        if (idx > 0) {
                            const friend = team[idx-1];
                            pet.swallowedPet = { dataId: friend.dataId };
                            team.splice(idx-1, 1);
                        }
                    } else if (pet.dataId === 'microbe') {
                        // Infect EVERYONE with weakness
                        [...team, ...otherTeam].forEach(p => p.item = 'weakness');
                    }
                }
                
                if (trigger === 'hurt') {
                    if (pet.dataId === 'peacock') {
                        pet.atk += Math.floor(pet.atk * 0.5 * pet.getDisplayLevel());
                    } else if (pet.dataId === 'blowfish') {
                         const num = 1; // Always 1 enemy? Or scales dmg? "Deal 2 damage * Lvl".
                         if (otherTeam.length > 0) {
                             const t = otherTeam[Math.floor(Math.random() * otherTeam.length)];
                             t.hp -= 2 * pet.getDisplayLevel();
                             showDamage(t, 2 * pet.getDisplayLevel());
                         }
                    } else if (pet.dataId === 'camel') {
                         const idx = team.indexOf(pet);
                         if (idx < team.length - 1) {
                             const friend = team[idx+1];
                             friend.atk += 1 * pet.getDisplayLevel();
                             friend.hp += 2 * pet.getDisplayLevel();
                         }
                    }
                }
                
                if (trigger === 'before_attack') {
                     if (pet.dataId === 'elephant') {
                         const idx = team.indexOf(pet);
                         const num = pet.getDisplayLevel();
                         for (let k=1; k<=num; k++) {
                             if (idx + k < team.length) {
                                 const friend = team[idx+k];
                                 friend.hp -= 1;
                                 showDamage(friend, 1);
                                 await this.triggerSpecificAbility(friend, 'hurt', team, otherTeam);
                             }
                         }
                     } else if (pet.dataId === 'boar') {
                         pet.atk += 4 * pet.getDisplayLevel();
                         pet.hp += 2 * pet.getDisplayLevel();
                     } else if (pet.dataId === 'octopus') {
                         const dmg = 3 * pet.getDisplayLevel();
                         if (otherTeam.length > 0) {
                             const indices = otherTeam.map((_, i) => i);
                             const targets = [];
                             for(let k=0; k<2; k++) {
                                 if (indices.length === 0) break;
                                 const r = Math.floor(Math.random() * indices.length);
                                 targets.push(otherTeam[indices.splice(r, 1)[0]]);
                             }
                             
                             for(const t of targets) {
                                 t.hp -= dmg;
                                 showDamage(t, dmg);
                                 if (t.hp > 0) await this.triggerSpecificAbility(t, 'hurt', otherTeam, team);
                             }
                         }
                     }
                }

                if (trigger === 'friend_ahead_attack') {
                     if (pet.dataId === 'kangaroo') {
                         if (contextPet && team.indexOf(contextPet) === team.indexOf(pet) - 1) {
                             pet.atk += 2 * pet.getDisplayLevel();
                             pet.hp += 2 * pet.getDisplayLevel();
                         }
                     } else if (pet.dataId === 'snake') {
                         if (contextPet && team.indexOf(contextPet) === team.indexOf(pet) - 1) {
                             if (otherTeam.length > 0) {
                                 const target = otherTeam[Math.floor(Math.random() * otherTeam.length)];
                                 target.hp -= 5 * pet.getDisplayLevel();
                                 showDamage(target, 5 * pet.getDisplayLevel());
                                 createProjectile(pet, target, 'rock');
                             }
                         }
                     }
                }
                
                if (trigger === 'knock_out') {
                    if (pet.dataId === 'hippo') {
                        pet.atk += 3 * pet.getDisplayLevel();
                        pet.hp += 3 * pet.getDisplayLevel();
                    } else if (pet.dataId === 'rhino') {
                        if (otherTeam.length > 0) {
                            const target = otherTeam[0];
                            target.hp -= 4 * pet.getDisplayLevel();
                            showDamage(target, 4 * pet.getDisplayLevel());
                        }
                    }
                }

                if (trigger === 'faint') {
                    if (pet.dataId === 'ant') {
                        const friends = team.filter(p => p !== pet && p.hp > 0); 
                        if (friends.length > 0) {
                            const f = friends[Math.floor(Math.random() * friends.length)];
                            f.atk += 2 * pet.getDisplayLevel();
                            f.hp += 1 * pet.getDisplayLevel();
                        }
                    } else if (pet.dataId === 'hedgehog') {
                        [...team, ...otherTeam].forEach(p => {
                            if (p !== pet && p.hp > 0) {
                                p.hp -= 2 * pet.getDisplayLevel();
                                showDamage(p, 2 * pet.getDisplayLevel());
                            }
                        });
                    } else if (pet.dataId === 'flamingo') {
                         const idx = team.indexOf(pet);
                         for (let k=1; k<=2; k++) {
                             if (idx + k < team.length) {
                                 const f = team[idx+k];
                                 f.atk += 1 * pet.getDisplayLevel();
                                 f.hp += 1 * pet.getDisplayLevel();
                             }
                         }
                    } else if (pet.dataId === 'badger') {
                        const idx = team.indexOf(pet);
                        const dmg = pet.atk;
                        // Friend behind
                        if (idx < team.length - 1) {
                            team[idx+1].hp -= dmg;
                            showDamage(team[idx+1], dmg);
                        }
                        // Enemy ahead (if at front)
                        // If Badger faints, it might be at front.
                        // But fainting happens after damage.
                        // If it was at front, enemy is at front of other team.
                        if (idx === 0 && otherTeam.length > 0) {
                            otherTeam[0].hp -= dmg;
                             showDamage(otherTeam[0], dmg);
                        }
                    } else if (pet.dataId === 'mammoth') {
                        team.forEach(p => {
                            if (p !== pet && p.hp > 0) {
                                p.atk += 2 * pet.getDisplayLevel();
                                p.hp += 2 * pet.getDisplayLevel();
                            }
                        });
                    }
                    
                    await this.triggerAbility('friend_faints', team, otherTeam, pet);
                }
                
                if (trigger === 'friend_faints') {
                    // pet is the observer, contextPet is the fainted one
                    if (pet.dataId === 'ox') {
                         if (team.indexOf(contextPet) === team.indexOf(pet) - 1) {
                             pet.atk += 2 * pet.getDisplayLevel();
                             pet.item = 'melon'; 
                         }
                    } else if (pet.dataId === 'shark') {
                        pet.atk += 2 * pet.getDisplayLevel();
                        pet.hp += 2 * pet.getDisplayLevel();
                    }
                }
            }
        }

        // --- Render Functions ---

        const game = new Game();

        function closeModal(id) {
            document.getElementById(id).style.display = 'none';
        }
        
        document.getElementById('btn-start-game').onclick = () => {
            document.getElementById('start-menu').style.display = 'none';
            game.render();
        };

        document.getElementById('btn-help').onclick = () => document.getElementById('help-modal').style.display = 'flex';
        document.getElementById('btn-settings').onclick = () => document.getElementById('settings-modal').style.display = 'flex';
        
        let fastMode = false;
        document.getElementById('chk-fast-mode').onchange = (e) => fastMode = e.target.checked;

        function renderGame(g) {
            document.getElementById('lives').innerText = g.lives;
            document.getElementById('gold').innerText = g.gold;
            document.getElementById('turn').innerText = g.turn;
            document.getElementById('wins').innerText = g.wins;

            const shopContainer = document.getElementById('shop-container');
            shopContainer.innerHTML = '';
            
            if (g.state === 'shop') {
                document.getElementById('shop-view').style.display = 'block';
                document.getElementById('enemy-container').style.display = 'none';
                document.getElementById('controls-area').style.display = 'flex';
                
                g.shopPets.forEach((pet, index) => {
                    const card = createPetCard(g, pet, index, 'shop');
                    shopContainer.appendChild(card);
                });

                const shopFoodContainer = document.getElementById('shop-food-container');
                shopFoodContainer.innerHTML = '';
                g.shopFood.forEach((food, index) => {
                    const card = createFoodCard(g, food, index);
                    shopFoodContainer.appendChild(card);
                });
            } else {
                document.getElementById('shop-view').style.display = 'none';
                document.getElementById('enemy-container').style.display = 'flex';
                document.getElementById('controls-area').style.display = 'none';
            }

            const teamContainer = document.getElementById('team-container');
            teamContainer.innerHTML = '';
            for(let i=0; i<5; i++) {
                const pet = g.team[i];
                if (pet) {
                    const card = createPetCard(g, pet, i, 'team');
                    teamContainer.appendChild(card);
                } else {
                    const slot = document.createElement('div');
                    slot.className = 'pet-card';
                    slot.style.opacity = '0.3';
                    slot.style.border = '2px dashed #aaa';
                    slot.style.background = 'transparent';
                    slot.onclick = () => onSlotClick(i);
                    teamContainer.appendChild(slot);
                }
            }

            if (g.state === 'battle') {
                renderBattleTeams(g.battleTeam, g.battleEnemyTeam);
            }
        }

        function renderBattleTeams(myTeam, enemyTeam) {
            const teamContainer = document.getElementById('team-container');
            teamContainer.innerHTML = '';
            myTeam.forEach((pet, i) => {
                teamContainer.appendChild(createPetCard(null, pet, i, 'battle-mine'));
            });

            const enemyContainer = document.getElementById('enemy-container');
            enemyContainer.innerHTML = '';
            enemyTeam.forEach((pet, i) => {
                enemyContainer.appendChild(createPetCard(null, pet, i, 'battle-enemy'));
            });
        }

        function createPetCard(g, pet, index, context) {
            const div = document.createElement('div');
            div.className = `pet-card ${pet.frozen ? 'frozen' : ''}`;
            if (g && context === 'team' && g.selectedTeamIndex === index) div.classList.add('selected');
            if (g && context === 'shop' && g.selectedShopItem && g.selectedShopItem.type === 'pet' && g.selectedShopItem.index === index) div.classList.add('selected');

            const tierColor = TIERS[pet.tier]?.color || '#ccc';
            const level = pet.getDisplayLevel();
            
            // Level visualization (SAP uses segments)
            let xpHtml = '';
            if (level < 3) {
                const currentXp = level === 1 ? pet.xp : pet.xp - 2;
                const nextXp = level === 1 ? 2 : 3;
                // Create segments
                let segments = '';
                for(let k=0; k<nextXp; k++) {
                     const filled = k < currentXp;
                     segments += `<div class="xp-segment ${filled?'filled':''}"></div>`;
                }
                xpHtml = `<div class="xp-bar">${segments}</div>`;
            } else {
                xpHtml = `<div class="xp-max">MAX</div>`;
            }
            
            const itemData = pet.item ? FOOD_DATA[pet.item] : null;

            div.innerHTML = `
                <div class="pet-bg" style="background-color: ${tierColor};"></div>
                <div class="pet-content">
                    <div class="pet-emoji">${pet.emoji}</div>
                </div>
                <div class="pet-info-top">
                    <div class="pet-level-badge">Lv.${level}</div>
                    ${xpHtml}
                </div>
                ${pet.item ? `<div class="pet-item-icon" title="${itemData ? itemData.name + ': ' + itemData.desc : ''}">${itemData ? itemData.emoji : ''}</div>` : ''}
                <div class="pet-stats-bar">
                    <div class="stat-box atk">âš”ï¸ ${pet.totalAtk}</div>
                    <div class="stat-box hp">â¤ï¸ ${pet.totalHp}</div>
                </div>
            `;

            div.onmouseenter = (e) => showTooltip(e, PET_DATA[pet.dataId].desc);
            div.onmouseleave = hideTooltip;

            div.onclick = (e) => {
                if (context === 'shop') onShopPetClick(index);
                if (context === 'team') onTeamPetClick(index);
            };

            return div;
        }
        
        function createFoodCard(g, foodItem, index) {
            const data = FOOD_DATA[foodItem.id];
            const div = document.createElement('div');
            div.className = `food-card ${foodItem.frozen ? 'frozen' : ''}`;
            if (g && g.selectedShopItem && g.selectedShopItem.type === 'food' && g.selectedShopItem.index === index) div.classList.add('selected');
            
            div.innerHTML = `
                <div class="food-bg"></div>
                <div class="food-content">
                    <div class="food-emoji">${data.emoji}</div>
                    <div class="food-cost">ğŸ’° ${data.cost}</div>
                </div>
            `;
            
            div.onmouseenter = (e) => showTooltip(e, data.desc);
            div.onmouseleave = hideTooltip;
            div.onclick = () => onShopFoodClick(index);
            
            return div;
        }

        function onShopPetClick(index) {
            if (game.selectedShopItem && game.selectedShopItem.type === 'pet' && game.selectedShopItem.index === index) {
                game.selectedShopItem = null;
            } else {
                game.selectedShopItem = { type: 'pet', index };
                game.selectedTeamIndex = -1;
            }
            game.render();
        }

        function onShopFoodClick(index) {
            if (game.selectedShopItem && game.selectedShopItem.type === 'food' && game.selectedShopItem.index === index) {
                game.selectedShopItem = null;
            } else {
                game.selectedShopItem = { type: 'food', index };
                game.selectedTeamIndex = -1;
            }
            game.render();
        }

        function onTeamPetClick(index) {
            if (game.selectedShopItem) {
                if (game.selectedShopItem.type === 'pet') {
                    game.buyPet(game.selectedShopItem.index, index);
                } else {
                    game.buyFood(game.selectedShopItem.index, index);
                }
                game.selectedShopItem = null;
            } else {
                if (game.selectedTeamIndex === index) {
                    game.selectedTeamIndex = -1;
                } else if (game.selectedTeamIndex !== -1) {
                    game.movePet(game.selectedTeamIndex, index);
                    game.selectedTeamIndex = -1;
                } else {
                    game.selectedTeamIndex = index;
                }
            }
            
            const btnSell = document.getElementById('btn-sell');
            btnSell.style.display = game.selectedTeamIndex !== -1 ? 'flex' : 'none';
            
            game.render();
        }

        function onSlotClick(index) {
            if (game.selectedShopItem && game.selectedShopItem.type === 'pet') {
                game.buyPet(game.selectedShopItem.index, index);
                game.selectedShopItem = null;
            } else if (game.selectedTeamIndex !== -1) {
                game.movePet(game.selectedTeamIndex, index);
                game.selectedTeamIndex = -1;
            }
            game.render();
        }

        document.getElementById('btn-roll').onclick = () => game.rollShop();
        document.getElementById('btn-end').onclick = () => game.startBattle();
        document.getElementById('btn-sell').onclick = () => game.sellPet(game.selectedTeamIndex);
        document.getElementById('btn-freeze').onclick = () => {
            if (game.selectedShopItem) {
                game.freezeShopItem(game.selectedShopItem.type, game.selectedShopItem.index);
            }
        };

        function sleep(ms) { 
            if (fastMode) return new Promise(r => setTimeout(r, ms / 2));
            return new Promise(r => setTimeout(r, ms)); 
        }

        function showTooltip(e, text) {
            const tt = document.getElementById('tooltip');
            tt.innerText = text;
            tt.style.display = 'block';
            tt.style.left = e.pageX + 10 + 'px';
            tt.style.top = e.pageY + 10 + 'px';
        }

        function hideTooltip() {
            document.getElementById('tooltip').style.display = 'none';
        }

        function showOverlay(text) {
            const ov = document.getElementById('message-overlay');
            ov.innerText = text;
            ov.style.opacity = 1;
            setTimeout(() => ov.style.opacity = 0, 1500);
        }

        async function playAttackAnim(p1, p2) {
            const teamContainer = document.getElementById('team-container');
            const enemyContainer = document.getElementById('enemy-container');
            
            const card1 = teamContainer.children[0];
            const card2 = enemyContainer.children[0];
            
            if(card1) card1.classList.add('anim-attack-right');
            if(card2) card2.classList.add('anim-attack-left');
            
            await sleep(300);
            
            if(card1) card1.classList.remove('anim-attack-right');
            if(card2) card2.classList.remove('anim-attack-left');
            
            if(card1) card1.classList.add('anim-hurt');
            if(card2) card2.classList.add('anim-hurt');
            
            await sleep(400);
             if(card1) card1.classList.remove('anim-hurt');
            if(card2) card2.classList.remove('anim-hurt');
        }
        
        function showDamage(pet, dmg) {
            let container = null;
            let index = -1;
            
            if (game.battleTeam.includes(pet)) {
                container = document.getElementById('team-container');
                index = game.battleTeam.indexOf(pet);
            } else if (game.battleEnemyTeam.includes(pet)) {
                container = document.getElementById('enemy-container');
                index = game.battleEnemyTeam.indexOf(pet);
            }
            
            if (container && container.children[index]) {
                const card = container.children[index];
                const dmgEl = document.createElement('div');
                dmgEl.className = 'damage-number';
                dmgEl.innerText = `-${dmg}`;
                dmgEl.style.left = '30%';
                dmgEl.style.top = '20%';
                card.appendChild(dmgEl);
                setTimeout(() => dmgEl.remove(), 1000);
            }
        }
        
        function createProjectile(fromPet, toPet, type) {
             let fromEl, toEl;
             
             if (game.battleTeam.includes(fromPet)) {
                 fromEl = document.getElementById('team-container').children[game.battleTeam.indexOf(fromPet)];
             } else {
                 fromEl = document.getElementById('enemy-container').children[game.battleEnemyTeam.indexOf(fromPet)];
             }
             
             if (game.battleTeam.includes(toPet)) {
                 toEl = document.getElementById('team-container').children[game.battleTeam.indexOf(toPet)];
             } else {
                 toEl = document.getElementById('enemy-container').children[game.battleEnemyTeam.indexOf(toPet)];
             }
             
             if (!fromEl || !toEl) return;
             
             const rect1 = fromEl.getBoundingClientRect();
             const rect2 = toEl.getBoundingClientRect();
             
             const p = document.createElement('div');
             p.className = 'projectile';
             p.innerText = 'ğŸª¨';
             p.style.left = rect1.left + rect1.width/2 + 'px';
             p.style.top = rect1.top + 'px';
             document.body.appendChild(p);
             
             setTimeout(() => {
                 p.style.left = rect2.left + rect2.width/2 + 'px';
                 p.style.top = rect2.top + 'px';
             }, 50);
             
             setTimeout(() => p.remove(), 550);
        }

    </script>
</body>
</html>
